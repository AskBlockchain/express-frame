{"version":3,"sources":["../src/index.ts","../src/core/utils.ts","../src/core/getFrameMetadata.ts","../src/core/validateFrameMessage.ts","../src/core/decodedFrameMetadata.ts","../src/core/sendAnalytics.ts","../src/core/convertUrlToIPFS.ts","../src/core/getUserByFid.ts","../src/core/getAddressForFid.ts","../src/core/checkForReplay.ts","../src/middleware/analyticsMiddleware.ts","../src/core/pinataFDK.ts"],"sourcesContent":["export * from \"./core/types\"\nexport * from \"./core/utils\"\nexport * from \"./core/pinataFDK\"","import {  FrameButtonMetadata, FrameHTMLType, PinataConfig } from \"./types\";\nimport { CastId} from \"@farcaster/core\";\n\nexport function bytesToHexString(bytes: Uint8Array): `0x${string}` {\n  return (\"0x\" + Buffer.from(bytes).toString(\"hex\")) as `0x${string}`;\n}\n\nexport function getByteLength(str: string): number {\n  return Buffer.from(str).byteLength;\n}\nexport function normalizeCastId(castId: CastId): {\n  fid: number;\n  hash: `0x${string}`;\n} {\n  return {\n    fid: castId.fid,\n    hash: bytesToHexString(castId.hash),\n  };\n}\n\nexport function hexStringToUint8Array(hexstring: string): Uint8Array {\n  return new Uint8Array(\n    hexstring.match(/.{1,2}/g)!.map((byte: string) => parseInt(byte, 16))\n  );\n}\n\n\n/**\n * Validates whether the version param is valid\n * @param version the version string to validate\n * @returns true if the provided version conforms to the Frames spec\n */\nexport function isValidVersion(version: string): boolean {\n  // Check if the input is exactly 'vNext'\n  if (version === \"vNext\") {\n    return true;\n  }\n\n  // Regular expression to match the pattern YYYY-MM-DD\n  // ^ asserts position at start of the string\n  // \\d{4} matches exactly four digits (for the year)\n  // - matches the literal \"-\"\n  // \\d{2} matches exactly two digits (for the month)\n  // - matches the literal \"-\"\n  // \\d{2} matches exactly two digits (for the day)\n  // $ asserts position at the end of the string\n  const pattern = /^\\d{4}-\\d{2}-\\d{2}$/;\n\n  // Test the input against the pattern\n  if (!pattern.test(version)) {\n    return false;\n  }\n\n  return true;\n}\n\nexport const parseFrameDetails = (frameDetails: FrameHTMLType, config?: PinataConfig): Record<string, string> => {\n   const {\n    buttons,\n    image,\n    cid,\n    aspect_ratio,\n    input,\n    post_url,\n    refresh_period,\n    state,\n  } = frameDetails;\n    const metadata: Record<string, string> = {\n    'fc:frame': 'vNext',\n    };\n    if(cid && config){\n      metadata[\"og:image\"] = `${config.pinata_gateway}/ipfs/${cid}`;\n      metadata['fc:frame:image'] = `${config.pinata_gateway}/ipfs/${cid}`;\n    }\n    else if (image && image.url) {\n      metadata[\"og:image\"] = image.url;\n      metadata['fc:frame:image'] = image.url;\n    } \n\n    if (input) {\n      if (input.text.length > 32) {\n        throw new Error(\"Input text exceeds maximum length of 32 bytes.\");\n      }\n      metadata['fc:frame:input:text'] = input.text;\n    }\n\n    if (buttons) {\n    if (buttons.length > 4) {\n      throw new Error(\"Maximum of 4 buttons allowed.\");\n    }\n    buttons.forEach((button: FrameButtonMetadata, index: number) => {\n      if (!button.label || button.label.length > 256) {\n        throw new Error(\"Button label is required and must be maximum of 256 bytes.\");\n      }\n      metadata[`fc:frame:button:${index + 1}`] = button.label;\n      if (button.action) {\n        if (!['post', 'post_redirect', 'mint', \"link\"].includes(button.action)) {\n          throw new Error(\"Invalid button action.\");\n        }\n        metadata[`fc:frame:button:${index + 1}:action`] = button.action;\n      } else {\n        metadata[`fc:frame:button:${index + 1}:action`] = 'post'; // Default action\n      }\n      if (button.target) {\n        metadata[`fc:frame:button:${index + 1}:target`] = button.target;\n      }\n    });\n    }\n\n    if(aspect_ratio){\n    metadata['fc:frame:image:aspect_ratio'] = aspect_ratio;\n    }\n\n    if (post_url) {\n    metadata['fc:frame:post_url'] = post_url;\n    }\n\n    if (refresh_period) {\n    if (refresh_period < 0) {\n      throw new Error(\"Refresh period must be a positive number.\");\n    }\n    metadata['fc:frame:refresh_period'] = refresh_period.toString();\n    }\n    \n    if(state) {\n      metadata['fc:frame:state'] = encodeURIComponent(JSON.stringify(state))\n    }\n    return metadata;\n}\n\n\n\nexport const uploadByURL = async (url: string, config: PinataConfig) => {\n  try {\n    const urlStream = await fetch(url);\n    const arrayBuffer = await urlStream.arrayBuffer();\n    const blob = new Blob([arrayBuffer]);\n\n    const data = new FormData();\n    data.append(\"file\", blob);\n    const upload = await fetch('https://api.pinata.cloud/pinning/pinFileToIPFS', {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${config.pinata_jwt}`,\n      },\n      body: data\n    });\n    const uploadRes = await upload.json();\n    return uploadRes;\n  } catch (error){\n    console.log(error);\n    return error;\n  }\n}\n\n\n","import { FrameHTMLType,  PinataConfig} from './types';\nimport { parseFrameDetails } from './utils';\n\n/**\n * This function generates the head metadata for a Farcaster Frame.\n * @param buttons: The buttons to use for the frame. (optional)\n * @param image: The url to use for the frame and upload IPFS boolean.\n * @param cid: The cid of the image to use for the frame.\n * @param input: The text input to use for the frame. (optional)\n * @param post_url: The URL to post the frame to. (optional)\n * @param refresh_period: The refresh period for the image used. (optional)\n * @param aspect_ratio: The aspect ratio for the image used. (optional)\n * @param state: The object (e.g. JSON) representing state data for the frame. (optional)\n * @returns The raw string HTML for a frame.\n */\n \nexport function getFrameMetadata (frameDetails: FrameHTMLType, config?: PinataConfig): string {\n  const metadata: Record<string, string> = parseFrameDetails(frameDetails, config);\n  let metaTags = '';\n  for (const key in metadata) {\n    metaTags += `<meta name=\"${key}\" content=\"${metadata[key]}\">\\n`;\n  }\n  return metaTags;\n};\n","import { FrameActionPayload } from \"./types\";\nimport { hexStringToUint8Array } from \"./utils\";\nimport { Message } from \"@farcaster/core\";\n\n/**\n * Validates a frame message by querying a Farcaster hub.\n * @param body The frame action payload containing the message to validate.\n * @returns A Promise that resolves with an object containing whether the message signature is valid and the validated message.\n */\nexport async function validateFrameMessage(body: FrameActionPayload): Promise<{\n  isValid: boolean;\n  message: Message | undefined;\n}> {\n  const hubBaseUrl = \"https://hub.pinata.cloud\";\n  const data = body.trustedData.messageBytes\n  const validateMessageResponse = await fetch(\n    `${hubBaseUrl}/v1/validateMessage`,\n    {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/octet-stream\",\n      },\n      body: hexStringToUint8Array(data),\n    }\n  );\n  const result = await validateMessageResponse.json()\n\n  if (result && result.valid) {        \n      return {\n      isValid: result.valid,\n      message: result.message\n    };\n  } else {\n    return {\n      isValid: false,\n      message: undefined,\n    };\n  }\n}\n\n\n\n","import { FrameHTMLType, PinataConfig} from './types';\nimport { parseFrameDetails } from './utils';\n\n\n/**\n * This function generates the head metadata for a Farcaster Frame.\n * @param buttons: The buttons to use for the frame.\n * @param image: The url to use for the frame and upload IPFS boolean.\n * @param cid: The cid of the image to use for the frame.\n * @param input: The text input to use for the frame.\n * @param post_url: The URL to post the frame to.\n * @param refresh_period: The refresh period for the image used.\n * @param aspect_ratio: The aspect ratio for the image used.\n * @returns The key value pairs of the metadata for a frame.\n */\n \n \nexport function decodedFrameMetadata (frameDetails: FrameHTMLType, config?: PinataConfig): Record<string, string> {\n    const metadata: Record<string, string> =  parseFrameDetails(frameDetails, config);\n    return metadata;\n};\n","import { FrameActionPayload, PinataConfig} from './types';\n\ntype DataObject = {\n    data: FrameActionPayload;\n    frame_id: string;\n    custom_id?: string; // Make custom_id optional\n}\n\n\n/**\n * This function sends frame data to track analytics.\n * @param frame_id: The id representing the frame.\n * @param frame_data: The Frame Action data produced by Farcasater.\n * @param custom_id: A unique identifier to segment requests within the specified frame (Optional) \n * @returns Success message boolean.\n */\n\nexport async function sendAnalytics(frame_id: string, frame_data: FrameActionPayload, config: PinataConfig | undefined, custom_id?: string) {\n    if(!config){\n      throw new Error('Pinata configuration required to send analytics.')\n    } \n    const postData: DataObject = {\n        frame_id: frame_id,\n        data: frame_data\n\n    } \n    if (custom_id) {\n        postData.custom_id = custom_id;\n    }\n\n    try {\n        const result = await fetch(\n            \"https://api.pinata.cloud/farcaster/frames/interactions\",\n            {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"Authorization\": `Bearer ${config?.pinata_jwt}`\n                },\n                body: JSON.stringify(postData),\n            }\n        );\n\n        if (result.ok) {\n            return { success: true };\n        } else {            \n            throw new Error(`Request failed with status ${result.status}`);\n        }\n    } catch (error: any) {\n        console.log(error);\n        throw new Error(error);\n    }\n}\n\n","import { PinataConfig} from './types';\nimport { uploadByURL } from \"./utils\";\n\n\n/**\n * This function uploads a url to ipfs and returns a Pinata IPFS url.\n * @param url: The url to be uploaded to IPFS.\n * @returns Pinata IPFS URL for the uploaded url.\n */\n\nexport async function convertUrlToIPFS(url: string, config: PinataConfig | undefined) {\n    if(!config){\n        throw new Error('Pinata configuration required to upload url to IPFS.')\n    }    \n    try {\n        const res = await uploadByURL(url, config);\n        if(res.IpfsHash){\n            return `${config.pinata_gateway}/ipfs/${res.IpfsHash}`;\n        }\n    } catch (error) {\n        throw new Error(\"Error uploading url to ipfs: \" + error);\n    }\n}\n\n","\n/**\n * This function returns user data associated with a given fid.\n * @param fid: The FID of a user.\n * @returns Data associated with the user.\n */\n\nexport const getUserByFid = async (fid: number) => {\n    const res = await fetch(`https://hub.pinata.cloud/v1/userDataByFid?fid=${fid}`)\n    const json = await res.json();\n    const { messages } = json;\n    const usernamePayload = messages.find((m: any) => m.data.userDataBody.type === \"USER_DATA_TYPE_USERNAME\")\n    const username = usernamePayload.data.userDataBody.value;\n    const pfpPayload = messages.find((m: any) => m.data.userDataBody.type === \"USER_DATA_TYPE_PFP\")\n    const pfp = pfpPayload.data.userDataBody.value;\n    const bioPayload = messages.find((m: any) => m.data.userDataBody.type === \"USER_DATA_TYPE_BIO\")\n    const bio = bioPayload.data.userDataBody.value;\n    return {\n      fid: fid, \n      username, \n      pfp, \n      bio\n    }\n}","\n\n/**\n * This function returns the connected Ethereum address for an FID.\n * @param fid: The FID of a user.\n * @returns The Ethereum address of the user.\n */\n\nexport const getAddressForFid = async (fid: number) => {\n  const res = await fetch(`https://hub.pinata.cloud/v1/verificationsByFid?fid=${fid}`)\n   const json = await res.json();\n  \n   const address = json.messages.map((m: any) => m.data.verificationAddAddressBody.address)\n   return address[0]\n  }\n  ","import { FrameActionPayload, PinataConfig} from './types';\n\ntype DataObject = {\n    fid: number;\n    frame_id: string;\n    cast_hash: string;\n    message_bytes: string;    \n}\n\n\n/**\n * This function sends frame data to and checks if the frame's message signature has been used before.\n * @param frame_id: The id representing the frame.\n * @param frame_data: The Frame Action data produced by Farcasater. \n * @returns Success message boolean.\n */\n\nexport async function checkForReplays(frame_id: string, frame_data: FrameActionPayload, config: PinataConfig | undefined) {\n    if(!config){\n      throw new Error('Pinata configuration required to send analytics.')\n    } \n    const postData: DataObject = {\n        frame_id: frame_id,\n        fid: frame_data.untrustedData.fid,\n        cast_hash: frame_data.untrustedData.messageHash,\n        message_bytes: frame_data.trustedData.messageBytes\n    } \n\n    try {\n        const result = await fetch(\n            \"https://api.pinata.cloud/v3/farcaster/frame_message_signature_replay\",\n            {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"Authorization\": `Bearer ${config?.pinata_jwt}`\n                },\n                body: JSON.stringify(postData),\n            }\n        );\n\n        const response = await result.json();\n        return response;\n    } catch (error) {\n        console.log(error);\n        console.error(\"Error sending analytics:\", error);\n        return { success: false };\n    }\n}\n\n","import { AnalyticsOptions, PinataConfig } from \"../core/types\";\nimport { sendAnalytics } from \"../core/sendAnalytics\";\nimport type { MiddlewareHandler } from \"hono\";\n\n\nexport const analyticsMiddleware = (\n  options: AnalyticsOptions,\n  config: PinataConfig | undefined\n): MiddlewareHandler => {\n  return async function analyticsMiddleware(c, next) {\n    if (!config) {\n      throw new Error(\"Pinata configuration required to send analytics.\");\n    }\n    try {\n      if (c.req.method === \"POST\") {\n        const body = await c.req.json();\n        await sendAnalytics(\n          options.frameId,\n          body,\n          config,\n          options.customId,\n        );\n      }\n      await next();\n    } catch (error) {\n      console.log(error);\n      return c.res = new Response(\"Error sending analytics\");\n    }\n  };\n};\n","import { getFrameMetadata } from \"./getFrameMetadata\";\nimport { validateFrameMessage } from \"./validateFrameMessage\";\nimport { FrameHTMLType, ReplayResponse, UserData, FrameActionPayload, AnalyticsOptions } from \"./types\";\nimport { PinataConfig } from \"./types\";\nimport { decodedFrameMetadata } from \"./decodedFrameMetadata\";\nimport { Message } from \"@farcaster/core\";\nimport { sendAnalytics } from \"./sendAnalytics\";\nimport { convertUrlToIPFS } from \"./convertUrlToIPFS\";\nimport { getUserByFid } from \"./getUserByFid\";\nimport { getAddressForFid } from \"./getAddressForFid\";\nimport { checkForReplays } from \"./checkForReplay\";\nimport { analyticsMiddleware } from \"../middleware/analyticsMiddleware\"\n\n\nconst formatConfig = (config: PinataConfig | undefined) => {\n    let gateway = config?.pinata_gateway;\n    if(config && gateway){\n        if(gateway && !gateway.startsWith('https://')){\n            gateway = `https://${gateway}`;\n        }\n        config.pinata_gateway = gateway;\n    }\n    return config\n}\n\nexport class PinataFDK {\n    config: PinataConfig | undefined\n\n    constructor(config?: PinataConfig) {\n        this.config = formatConfig(config)\n    }\n    getFrameMetadata(metadata: FrameHTMLType): string{\n        return getFrameMetadata(metadata, this.config)\n    }\n\n    validateFrameMessage(payload: FrameActionPayload): Promise<{\n        isValid: boolean;\n        message: Message | undefined;\n      }>{\n        return validateFrameMessage(payload)\n    }\n\n    decodedFrameMetadata(metadata: FrameHTMLType): Record<string, string>{\n        return decodedFrameMetadata(metadata, this.config)\n    }\n\n    sendAnalytics(frame_id: string, frame_data: FrameActionPayload, custom_id?: string): Promise<{ success: boolean }>{\n        return sendAnalytics(frame_id, frame_data, this.config, custom_id)\n    }\n\n    convertUrlToIPFS(url: string): Promise<string | undefined>{\n        return convertUrlToIPFS(url, this.config)\n    }\n\n    getUserByFid(fid: number): Promise<UserData>{\n        return getUserByFid(fid)\n    }\n\n    getEthAddressForFid(fid: number): Promise<string>{\n        return getAddressForFid(fid)\n    }\n\n    checkForReplays(frame_id: string, frame_data: FrameActionPayload) : Promise<ReplayResponse> {\n        return checkForReplays(frame_id, frame_data, this.config)\n    }\n\n    analyticsMiddleware(options: AnalyticsOptions) {\n        return analyticsMiddleware(options, this.config)\n    }\n }\n"],"mappings":"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","names":["analyticsMiddleware"]}