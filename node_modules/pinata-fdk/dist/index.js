"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  PinataFDK: () => PinataFDK,
  bytesToHexString: () => bytesToHexString,
  getByteLength: () => getByteLength,
  hexStringToUint8Array: () => hexStringToUint8Array,
  isValidVersion: () => isValidVersion,
  normalizeCastId: () => normalizeCastId,
  parseFrameDetails: () => parseFrameDetails,
  uploadByURL: () => uploadByURL
});
module.exports = __toCommonJS(src_exports);

// src/core/utils.ts
function bytesToHexString(bytes) {
  return "0x" + Buffer.from(bytes).toString("hex");
}
function getByteLength(str) {
  return Buffer.from(str).byteLength;
}
function normalizeCastId(castId) {
  return {
    fid: castId.fid,
    hash: bytesToHexString(castId.hash)
  };
}
function hexStringToUint8Array(hexstring) {
  return new Uint8Array(
    hexstring.match(/.{1,2}/g).map((byte) => parseInt(byte, 16))
  );
}
function isValidVersion(version) {
  if (version === "vNext") {
    return true;
  }
  const pattern = /^\d{4}-\d{2}-\d{2}$/;
  if (!pattern.test(version)) {
    return false;
  }
  return true;
}
var parseFrameDetails = (frameDetails, config) => {
  const {
    buttons,
    image,
    cid,
    aspect_ratio,
    input,
    post_url,
    refresh_period,
    state
  } = frameDetails;
  const metadata = {
    "fc:frame": "vNext"
  };
  if (cid && config) {
    metadata["og:image"] = `${config.pinata_gateway}/ipfs/${cid}`;
    metadata["fc:frame:image"] = `${config.pinata_gateway}/ipfs/${cid}`;
  } else if (image && image.url) {
    metadata["og:image"] = image.url;
    metadata["fc:frame:image"] = image.url;
  }
  if (input) {
    if (input.text.length > 32) {
      throw new Error("Input text exceeds maximum length of 32 bytes.");
    }
    metadata["fc:frame:input:text"] = input.text;
  }
  if (buttons) {
    if (buttons.length > 4) {
      throw new Error("Maximum of 4 buttons allowed.");
    }
    buttons.forEach((button, index) => {
      if (!button.label || button.label.length > 256) {
        throw new Error("Button label is required and must be maximum of 256 bytes.");
      }
      metadata[`fc:frame:button:${index + 1}`] = button.label;
      if (button.action) {
        if (!["post", "post_redirect", "mint", "link"].includes(button.action)) {
          throw new Error("Invalid button action.");
        }
        metadata[`fc:frame:button:${index + 1}:action`] = button.action;
      } else {
        metadata[`fc:frame:button:${index + 1}:action`] = "post";
      }
      if (button.target) {
        metadata[`fc:frame:button:${index + 1}:target`] = button.target;
      }
    });
  }
  if (aspect_ratio) {
    metadata["fc:frame:image:aspect_ratio"] = aspect_ratio;
  }
  if (post_url) {
    metadata["fc:frame:post_url"] = post_url;
  }
  if (refresh_period) {
    if (refresh_period < 0) {
      throw new Error("Refresh period must be a positive number.");
    }
    metadata["fc:frame:refresh_period"] = refresh_period.toString();
  }
  if (state) {
    metadata["fc:frame:state"] = encodeURIComponent(JSON.stringify(state));
  }
  return metadata;
};
var uploadByURL = (url, config) => __async(void 0, null, function* () {
  try {
    const urlStream = yield fetch(url);
    const arrayBuffer = yield urlStream.arrayBuffer();
    const blob = new Blob([arrayBuffer]);
    const data = new FormData();
    data.append("file", blob);
    const upload = yield fetch("https://api.pinata.cloud/pinning/pinFileToIPFS", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${config.pinata_jwt}`
      },
      body: data
    });
    const uploadRes = yield upload.json();
    return uploadRes;
  } catch (error) {
    console.log(error);
    return error;
  }
});

// src/core/getFrameMetadata.ts
function getFrameMetadata(frameDetails, config) {
  const metadata = parseFrameDetails(frameDetails, config);
  let metaTags = "";
  for (const key in metadata) {
    metaTags += `<meta name="${key}" content="${metadata[key]}">
`;
  }
  return metaTags;
}

// src/core/validateFrameMessage.ts
function validateFrameMessage(body) {
  return __async(this, null, function* () {
    const hubBaseUrl = "https://hub.pinata.cloud";
    const data = body.trustedData.messageBytes;
    const validateMessageResponse = yield fetch(
      `${hubBaseUrl}/v1/validateMessage`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/octet-stream"
        },
        body: hexStringToUint8Array(data)
      }
    );
    const result = yield validateMessageResponse.json();
    if (result && result.valid) {
      return {
        isValid: result.valid,
        message: result.message
      };
    } else {
      return {
        isValid: false,
        message: void 0
      };
    }
  });
}

// src/core/decodedFrameMetadata.ts
function decodedFrameMetadata(frameDetails, config) {
  const metadata = parseFrameDetails(frameDetails, config);
  return metadata;
}

// src/core/sendAnalytics.ts
function sendAnalytics(frame_id, frame_data, config, custom_id) {
  return __async(this, null, function* () {
    if (!config) {
      throw new Error("Pinata configuration required to send analytics.");
    }
    const postData = {
      frame_id,
      data: frame_data
    };
    if (custom_id) {
      postData.custom_id = custom_id;
    }
    try {
      const result = yield fetch(
        "https://api.pinata.cloud/farcaster/frames/interactions",
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${config == null ? void 0 : config.pinata_jwt}`
          },
          body: JSON.stringify(postData)
        }
      );
      if (result.ok) {
        return { success: true };
      } else {
        throw new Error(`Request failed with status ${result.status}`);
      }
    } catch (error) {
      console.log(error);
      throw new Error(error);
    }
  });
}

// src/core/convertUrlToIPFS.ts
function convertUrlToIPFS(url, config) {
  return __async(this, null, function* () {
    if (!config) {
      throw new Error("Pinata configuration required to upload url to IPFS.");
    }
    try {
      const res = yield uploadByURL(url, config);
      if (res.IpfsHash) {
        return `${config.pinata_gateway}/ipfs/${res.IpfsHash}`;
      }
    } catch (error) {
      throw new Error("Error uploading url to ipfs: " + error);
    }
  });
}

// src/core/getUserByFid.ts
var getUserByFid = (fid) => __async(void 0, null, function* () {
  const res = yield fetch(`https://hub.pinata.cloud/v1/userDataByFid?fid=${fid}`);
  const json = yield res.json();
  const { messages } = json;
  const usernamePayload = messages.find((m) => m.data.userDataBody.type === "USER_DATA_TYPE_USERNAME");
  const username = usernamePayload.data.userDataBody.value;
  const pfpPayload = messages.find((m) => m.data.userDataBody.type === "USER_DATA_TYPE_PFP");
  const pfp = pfpPayload.data.userDataBody.value;
  const bioPayload = messages.find((m) => m.data.userDataBody.type === "USER_DATA_TYPE_BIO");
  const bio = bioPayload.data.userDataBody.value;
  return {
    fid,
    username,
    pfp,
    bio
  };
});

// src/core/getAddressForFid.ts
var getAddressForFid = (fid) => __async(void 0, null, function* () {
  const res = yield fetch(`https://hub.pinata.cloud/v1/verificationsByFid?fid=${fid}`);
  const json = yield res.json();
  const address = json.messages.map((m) => m.data.verificationAddAddressBody.address);
  return address[0];
});

// src/core/checkForReplay.ts
function checkForReplays(frame_id, frame_data, config) {
  return __async(this, null, function* () {
    if (!config) {
      throw new Error("Pinata configuration required to send analytics.");
    }
    const postData = {
      frame_id,
      fid: frame_data.untrustedData.fid,
      cast_hash: frame_data.untrustedData.messageHash,
      message_bytes: frame_data.trustedData.messageBytes
    };
    try {
      const result = yield fetch(
        "https://api.pinata.cloud/v3/farcaster/frame_message_signature_replay",
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${config == null ? void 0 : config.pinata_jwt}`
          },
          body: JSON.stringify(postData)
        }
      );
      const response = yield result.json();
      return response;
    } catch (error) {
      console.log(error);
      console.error("Error sending analytics:", error);
      return { success: false };
    }
  });
}

// src/middleware/analyticsMiddleware.ts
var analyticsMiddleware = (options, config) => {
  return function analyticsMiddleware2(c, next) {
    return __async(this, null, function* () {
      if (!config) {
        throw new Error("Pinata configuration required to send analytics.");
      }
      try {
        if (c.req.method === "POST") {
          const body = yield c.req.json();
          yield sendAnalytics(
            options.frameId,
            body,
            config,
            options.customId
          );
        }
        yield next();
      } catch (error) {
        console.log(error);
        return c.res = new Response("Error sending analytics");
      }
    });
  };
};

// src/core/pinataFDK.ts
var formatConfig = (config) => {
  let gateway = config == null ? void 0 : config.pinata_gateway;
  if (config && gateway) {
    if (gateway && !gateway.startsWith("https://")) {
      gateway = `https://${gateway}`;
    }
    config.pinata_gateway = gateway;
  }
  return config;
};
var PinataFDK = class {
  constructor(config) {
    this.config = formatConfig(config);
  }
  getFrameMetadata(metadata) {
    return getFrameMetadata(metadata, this.config);
  }
  validateFrameMessage(payload) {
    return validateFrameMessage(payload);
  }
  decodedFrameMetadata(metadata) {
    return decodedFrameMetadata(metadata, this.config);
  }
  sendAnalytics(frame_id, frame_data, custom_id) {
    return sendAnalytics(frame_id, frame_data, this.config, custom_id);
  }
  convertUrlToIPFS(url) {
    return convertUrlToIPFS(url, this.config);
  }
  getUserByFid(fid) {
    return getUserByFid(fid);
  }
  getEthAddressForFid(fid) {
    return getAddressForFid(fid);
  }
  checkForReplays(frame_id, frame_data) {
    return checkForReplays(frame_id, frame_data, this.config);
  }
  analyticsMiddleware(options) {
    return analyticsMiddleware(options, this.config);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PinataFDK,
  bytesToHexString,
  getByteLength,
  hexStringToUint8Array,
  isValidVersion,
  normalizeCastId,
  parseFrameDetails,
  uploadByURL
});
//# sourceMappingURL=index.js.map