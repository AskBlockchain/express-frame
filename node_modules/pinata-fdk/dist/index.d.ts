import { CastId, Message } from '@farcaster/core';
import * as hono from 'hono';

type PinFileOptions = {
    pinataMetadata?: {
        name?: string;
        keyvalues?: Record<string, string>;
    };
    pinataOptions?: {
        cidVersion: number;
    };
};
/** The permitted types of `buttonIndex` in a Frame POST payload response */
type ActionIndex = 1 | 2 | 3 | 4;
type FrameInputMetadata = {
    text: string;
};
type UserData = {
    fid: number;
    username: string;
    pfp: string;
    bio: string;
};
type PinataConfig = {
    pinata_jwt: string;
    pinata_gateway: string;
};
type FrameHTMLType = {
    buttons?: [FrameButtonMetadata, ...FrameButtonMetadata[]];
    image?: {
        url: string;
    };
    cid?: string;
    input?: FrameInputMetadata;
    post_url?: string;
    refresh_period?: number;
    aspect_ratio?: "1.91:1" | "1:1";
    state?: object;
} & ({
    image: {
        url: string;
    };
} | {
    cid: string;
});
type FrameButtonMetadata = {
    label: string;
    action?: "post" | "post_redirect" | "mint" | "link" | "tx";
    target?: string;
};
interface ReplayResponse {
    data: {
        previously_used: boolean;
        message_bytes: string;
    };
}
type FrameMetadataResponse = Record<string, string>;
type AddressReturnType<Options extends {
    fallbackToCustodyAddress?: boolean;
} | undefined> = Options extends {
    fallbackToCustodyAddress: true;
} ? `0x${string}` : `0x${string}` | null;
/**
 * The body of valid `POST` requests triggered by Frame Buttons in other apps, when formatted as json, conforming to the Frames spec
 */
type FrameActionPayload = {
    /** once validated, should be the only trusted source for accessing frame data */
    trustedData: {
        messageBytes: string;
    };
    /**
     * untrustedData can be faked by anyone by hitting your frame with a POST with an arbitrary payload. We recommend only using
     * trustedData to do actions.
     */
    untrustedData: {
        /** the fid of the user who did the message. */
        fid: number;
        /** the url of the original frame, must be under 256 bytes */
        url: string;
        /** the hash of the `Farcaster` `AddFrameActionMessage` */
        messageHash: string;
        /** A Farcaster epoch timestamp (not UNIX timestamp) */
        timestamp: number;
        /** The Farcaster network is on network = 1 */
        network: number;
        /** the button index, starting from 1 that the user pressed to invoke this POST */
        buttonIndex: ActionIndex;
        /** the unique identifiers of the Farcaster cast, via the user who casted's `fid` and the cast `hash`, which is a unique identifier */
        castId: {
            fid: number;
            hash: string;
        };
        /** text input by the user into any input provided, "" if requested and no input, undefined if input not requested */
        inputText?: string;
    };
};
type AnalyticsOptions = {
    frameId: string;
    customId?: string;
};

declare function bytesToHexString(bytes: Uint8Array): `0x${string}`;
declare function getByteLength(str: string): number;
declare function normalizeCastId(castId: CastId): {
    fid: number;
    hash: `0x${string}`;
};
declare function hexStringToUint8Array(hexstring: string): Uint8Array;
/**
 * Validates whether the version param is valid
 * @param version the version string to validate
 * @returns true if the provided version conforms to the Frames spec
 */
declare function isValidVersion(version: string): boolean;
declare const parseFrameDetails: (frameDetails: FrameHTMLType, config?: PinataConfig) => Record<string, string>;
declare const uploadByURL: (url: string, config: PinataConfig) => Promise<any>;

declare class PinataFDK {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    getFrameMetadata(metadata: FrameHTMLType): string;
    validateFrameMessage(payload: FrameActionPayload): Promise<{
        isValid: boolean;
        message: Message | undefined;
    }>;
    decodedFrameMetadata(metadata: FrameHTMLType): Record<string, string>;
    sendAnalytics(frame_id: string, frame_data: FrameActionPayload, custom_id?: string): Promise<{
        success: boolean;
    }>;
    convertUrlToIPFS(url: string): Promise<string | undefined>;
    getUserByFid(fid: number): Promise<UserData>;
    getEthAddressForFid(fid: number): Promise<string>;
    checkForReplays(frame_id: string, frame_data: FrameActionPayload): Promise<ReplayResponse>;
    analyticsMiddleware(options: AnalyticsOptions): hono.MiddlewareHandler;
}

export { type ActionIndex, type AddressReturnType, type AnalyticsOptions, type FrameActionPayload, type FrameButtonMetadata, type FrameHTMLType, type FrameInputMetadata, type FrameMetadataResponse, type PinFileOptions, type PinataConfig, PinataFDK, type ReplayResponse, type UserData, bytesToHexString, getByteLength, hexStringToUint8Array, isValidVersion, normalizeCastId, parseFrameDetails, uploadByURL };
